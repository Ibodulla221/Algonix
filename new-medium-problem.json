{
  "slug": "binary-tree-level-order-traversal",
  "title": "Binary Tree darajalar bo'yicha o'tish",
  "difficulty": "MEDIUM",
  "categories": ["tree", "breadth-first-search", "binary-tree"],
  "tags": ["algorithms", "tree", "bfs", "binary-tree", "queue"],
  "description": "Berilgan binary tree ning ildizidan boshlab, har bir darajadagi tugunlarni chap-o'ngdan tartibda qaytaring. Natija 2D massiv ko'rinishida bo'lishi kerak, har bir ichki massiv bitta darajani ifodalaydi.",
  "descriptionHtml": "<p>Berilgan binary tree ning ildizidan boshlab, har bir darajadagi tugunlarni chap-o'ngdan tartibda qaytaring.</p><p>Natija 2D massiv ko'rinishida bo'lishi kerak, har bir ichki massiv bitta darajani ifodalaydi.</p>",
  "examples": [
    {
      "input": "root = [3,9,20,null,null,15,7]",
      "target": null,
      "output": "[[3],[9,20],[15,7]]",
      "explanation": "Darajalar: 1-daraja [3], 2-daraja [9,20], 3-daraja [15,7]"
    },
    {
      "input": "root = [1]",
      "target": null,
      "output": "[[1]]",
      "explanation": "Faqat bitta tugun bor"
    },
    {
      "input": "root = []",
      "target": null,
      "output": "[]",
      "explanation": "Bo'sh tree"
    }
  ],
  "constraints": [
    "Tree dagi tugunlar soni [0, 2000] oralig'ida",
    "-1000 <= Node.val <= 1000"
  ],
  "hints": [
    "BFS (Breadth-First Search) algoritmidan foydalaning",
    "Queue ma'lumotlar strukturasini ishlating",
    "Har bir darajani alohida qayta ishlang"
  ],
  "codeTemplates": {
    "java": "import java.util.*;\n\n// TreeNode klassi berilgan\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        // Sizning kodingiz\n    }\n}",
    "python": "from typing import List, Optional\n\n# TreeNode klassi berilgan\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order(root: Optional[TreeNode]) -> List[List[int]]:\n    # Sizning kodingiz\n    pass",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n// TreeNode struktura berilgan\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        // Sizning kodingiz\n    }\n};",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// TreeNode struktura berilgan\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nint** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\n    // Sizning kodingiz\n}",
    "javascript": "// TreeNode klassi berilgan\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\nfunction levelOrder(root) {\n    // Sizning kodingiz\n}\n\n// Quyidagi kodni o'zgartirmang\nexports.levelOrder = levelOrder;",
    "typescript": "// TreeNode klassi berilgan\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\nfunction levelOrder(root: TreeNode | null): number[][] {\n    // Sizning kodingiz\n}\n\n// Quyidagi kodni o'zgartirmang\nexport { levelOrder };",
    "go": "package main\n\n// TreeNode struktura berilgan\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc levelOrder(root *TreeNode) [][]int {\n    // Sizning kodingiz\n}",
    "kotlin": "// TreeNode klassi berilgan\nclass TreeNode(var `val`: Int) {\n    var left: TreeNode? = null\n    var right: TreeNode? = null\n}\n\nfun levelOrder(root: TreeNode?): List<List<Int>> {\n    // Sizning kodingiz\n}",
    "swift": "// TreeNode klassi berilgan\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nfunc levelOrder(_ root: TreeNode?) -> [[Int]] {\n    // Sizning kodingiz\n}",
    "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n// TreeNode struktura berilgan\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n  pub val: i32,\n  pub left: Option<Rc<RefCell<TreeNode>>>,\n  pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nfn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n    // Sizning kodingiz\n}",
    "ruby": "# TreeNode klassi berilgan\nclass TreeNode\n    attr_accessor :val, :left, :right\n    def initialize(val = 0, left = nil, right = nil)\n        @val = val\n        @left = left\n        @right = right\n    end\nend\n\ndef level_order(root)\n  # Sizning kodingiz\nend",
    "php": "<?php\n// TreeNode klassi berilgan\nclass TreeNode {\n    public $val = null;\n    public $left = null;\n    public $right = null;\n    function __construct($val = 0, $left = null, $right = null) {\n        $this->val = $val;\n        $this->left = $left;\n        $this->right = $right;\n    }\n}\n\nfunction levelOrder($root) {\n    // Sizning kodingiz\n}\n?>",
    "dart": "// TreeNode klassi berilgan\nclass TreeNode {\n  int val;\n  TreeNode? left;\n  TreeNode? right;\n  TreeNode([this.val = 0, this.left, this.right]);\n}\n\nList<List<int>> levelOrder(TreeNode? root) {\n  // Sizning kodingiz\n}",
    "scala": "// TreeNode klassi berilgan\nclass TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n  var value: Int = _value\n  var left: TreeNode = _left\n  var right: TreeNode = _right\n}\n\nobject Solution {\n  def levelOrder(root: TreeNode): List[List[Int]] = {\n    // Sizning kodingiz\n  }\n}",
    "elixir": "# TreeNode struktura berilgan\ndefmodule TreeNode do\n  @type t :: %__MODULE__{\n          val: integer,\n          left: TreeNode.t() | nil,\n          right: TreeNode.t() | nil\n        }\n  defstruct val: 0, left: nil, right: nil\nend\n\ndefmodule Solution do\n  def level_order(root) do\n    # Sizning kodingiz\n  end\nend",
    "erlang": "-module(solution).\n-export([level_order/1]).\n\n% TreeNode record berilgan\n-record(tree_node, {val = 0, left = null, right = null}).\n\nlevel_order(Root) ->\n    % Sizning kodingiz\n    ok.",
    "racket": "#lang racket\n\n; TreeNode struktura berilgan\n(struct tree-node (val left right) #:mutable #:transparent)\n\n(define (level-order root)\n  ; Sizning kodingiz\n  )",
    "csharp": "using System;\nusing System.Collections.Generic;\n\n// TreeNode klassi berilgan\npublic class TreeNode {\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class Solution {\n    public IList<IList<int>> LevelOrder(TreeNode root) {\n        // Sizning kodingiz\n    }\n}"
  },
  "testCases": [
    {
      "input": "[3,9,20,null,null,15,7]",
      "expectedOutput": "[[3],[9,20],[15,7]]",
      "isHidden": false,
      "timeLimitMs": 2000
    },
    {
      "input": "[1]",
      "expectedOutput": "[[1]]",
      "isHidden": false,
      "timeLimitMs": 2000
    },
    {
      "input": "[]",
      "expectedOutput": "[]",
      "isHidden": false,
      "timeLimitMs": 2000
    },
    {
      "input": "[1,2,3,4,5,6,7]",
      "expectedOutput": "[[1],[2,3],[4,5,6,7]]",
      "isHidden": true,
      "timeLimitMs": 2000
    },
    {
      "input": "[1,2,null,3,null,4,null,5]",
      "expectedOutput": "[[1],[2],[3],[4],[5]]",
      "isHidden": true,
      "timeLimitMs": 2000
    }
  ],
  "relatedProblems": [
    "binary-tree-zigzag-level-order-traversal",
    "binary-tree-level-order-traversal-ii",
    "minimum-depth-of-binary-tree"
  ],
  "companies": ["amazon", "microsoft", "facebook", "google", "apple"],
  "frequency": 0.85,
  "isPremium": false
}